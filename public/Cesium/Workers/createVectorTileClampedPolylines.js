define(["./AttributeCompression-48e336db","./Matrix3-81054f0f","./combine-0c102d93","./IndexDatatype-d3db4e7d","./Math-2ce22ee9","./Matrix2-413c4048","./createTaskProcessorWorker","./ComponentDatatype-ab629b88","./defaultValue-f6d5e6da","./WebGLConstants-7f557f93","./RuntimeError-9b4ce3fb"],function(e,t,a,r,s,n,i,l,o,d,f){"use strict";let c=Math.cos(s.CesiumMath.toRadians(150)),u=new t.Cartographic,h=new t.Cartesian3,C=new t.Cartographic,p=new t.Cartographic;function m(e){let t=8*e,a=3*t,s=4*t;this.startEllipsoidNormals=new Float32Array(a),this.endEllipsoidNormals=new Float32Array(a),this.startPositionAndHeights=new Float32Array(s),this.startFaceNormalAndVertexCornerIds=new Float32Array(s),this.endPositionAndHeights=new Float32Array(s),this.endFaceNormalAndHalfWidths=new Float32Array(s),this.vertexBatchIds=new Uint16Array(t),this.indices=r.IndexDatatype.createTypedArray(t,36*e),this.vec3Offset=0,this.vec4Offset=0,this.batchIdOffset=0,this.indexOffset=0,this.volumeStartIndex=0}let b=new t.Cartesian3,A=new t.Cartesian3;function w(e,a,r,s,n){let i=t.Cartesian3.subtract(r,a,A),l=t.Cartesian3.subtract(a,e,b);return t.Cartesian3.normalize(i,i),t.Cartesian3.normalize(l,l),t.Cartesian3.dot(i,l)<c&&(l=t.Cartesian3.multiplyByScalar(l,-1,b)),t.Cartesian3.add(i,l,n),t.Cartesian3.equals(n,t.Cartesian3.ZERO)&&(n=t.Cartesian3.subtract(e,a)),t.Cartesian3.cross(n,s,n),t.Cartesian3.cross(s,n,n),t.Cartesian3.normalize(n,n),n}let g=[0,2,6,0,6,4,0,1,3,0,3,2,0,4,5,0,5,1,5,3,1,5,7,3,7,5,4,7,4,6,7,6,2,7,2,3],y=g.length,N=new t.Cartesian3,k=new t.Cartesian3,x=new t.Cartesian3,I=new t.Cartesian3,E=new t.Cartesian3;m.prototype.addVolume=function(e,a,r,s,n,i,l,o,d,f){let c=t.Cartesian3.add(a,d,N),u=f.geodeticSurfaceNormal(c,k);c=t.Cartesian3.add(r,d,N);let h=f.geodeticSurfaceNormal(c,I),C=w(e,a,r,u,x),p=w(s,r,a,h,E),m=this.startEllipsoidNormals,b=this.endEllipsoidNormals,A=this.startPositionAndHeights,F=this.startFaceNormalAndVertexCornerIds,H=this.endPositionAndHeights,O=this.endFaceNormalAndHalfWidths,P=this.vertexBatchIds,v,D=this.batchIdOffset,M=this.vec3Offset,S=this.vec4Offset;for(v=0;v<8;v++)t.Cartesian3.pack(u,m,M),t.Cartesian3.pack(h,b,M),t.Cartesian3.pack(a,A,S),A[S+3]=n,t.Cartesian3.pack(r,H,S),H[S+3]=i,t.Cartesian3.pack(C,F,S),F[S+3]=v,t.Cartesian3.pack(p,O,S),O[S+3]=l,P[D++]=o,M+=3,S+=4;this.batchIdOffset=D,this.vec3Offset=M,this.vec4Offset=S;let R=this.indices,U=this.volumeStartIndex,B=this.indexOffset;for(v=0;v<y;v++)R[B+v]=g[v]+U;this.volumeStartIndex+=8,this.indexOffset+=y};let F=new n.Rectangle,H=new t.Ellipsoid,O=new t.Cartesian3,P=new t.Cartesian3,v=new t.Cartesian3,D=new t.Cartesian3,M=new t.Cartesian3;return i(function(i,l){let o;let d=new Uint16Array(i.positions),f=new Uint16Array(i.widths),c=new Uint32Array(i.counts),b=new Uint16Array(i.batchIds),A=new Float64Array(i.packedBuffer),w=0,g=A[w++],y=A[w++];n.Rectangle.unpack(A,w,F),w+=n.Rectangle.packedLength,t.Ellipsoid.unpack(A,w,H),w+=t.Ellipsoid.packedLength,t.Cartesian3.unpack(A,w,O);let N=d.length/3,k=d.subarray(0,N),x=d.subarray(N,2*N),I=d.subarray(2*N,3*N);e.AttributeCompression.zigZagDeltaDecode(k,x,I),function(e,a,r,s){let n=s.length,i=e.length,l=new Uint8Array(i),o=C,d=p,f=0;for(let r=0;r<n;r++){let n=s[r],i=n;for(let r=1;r<n;r++){let s=f+r,n=s-1;d.longitude=e[s],d.latitude=a[s],o.longitude=e[n],o.latitude=a[n],t.Cartographic.equals(d,o)&&(i--,l[n]=1)}s[r]=i,f+=n}let c=0;for(let t=0;t<i;t++)1!==l[t]&&(e[c]=e[t],a[c]=a[t],r[c]=r[t],c++)}(k,x,I,c);let E=c.length,S=0;for(o=0;o<E;o++)S+=c[o]-1;let R=new m(S),U=function(e,a,r,n,i,l,o){let d=e.length,f=new Float64Array(3*d);for(let c=0;c<d;++c){let d=e[c],C=a[c],p=r[c],m=s.CesiumMath.lerp(n.west,n.east,d/32767),b=s.CesiumMath.lerp(n.south,n.north,C/32767),A=s.CesiumMath.lerp(i,l,p/32767),w=t.Cartographic.fromRadians(m,b,A,u),g=o.cartographicToCartesian(w,h);t.Cartesian3.pack(g,f,3*c)}return f}(k,x,I,F,g,y,H);N=k.length;let B=new Float32Array(3*N);for(o=0;o<N;++o)B[3*o]=U[3*o]-O.x,B[3*o+1]=U[3*o+1]-O.y,B[3*o+2]=U[3*o+2]-O.z;let V=0,T=0;for(o=0;o<E;o++){let e=c[o]-1,a=.5*f[o],r=b[o],n=V;for(let i=0;i<e;i++){let l=t.Cartesian3.unpack(B,V,v),o=t.Cartesian3.unpack(B,V+3,D),d=I[T],f=I[T+1];d=s.CesiumMath.lerp(g,y,d/32767),f=s.CesiumMath.lerp(g,y,f/32767),T++;let c=P,u=M;if(0===i){let a=n+3*e,r=t.Cartesian3.unpack(B,a,P);if(t.Cartesian3.equals(r,l))t.Cartesian3.unpack(B,a-3,c);else{let e=t.Cartesian3.subtract(l,o,P);c=t.Cartesian3.add(e,l,P)}}else t.Cartesian3.unpack(B,V-3,c);if(i===e-1){let e=t.Cartesian3.unpack(B,n,M);if(t.Cartesian3.equals(e,o))t.Cartesian3.unpack(B,n+3,u);else{let e=t.Cartesian3.subtract(o,l,M);u=t.Cartesian3.add(e,o,M)}}else t.Cartesian3.unpack(B,V+6,u);R.addVolume(c,l,o,u,d,f,a,r,O,H),V+=3}V+=3,T++}let W=R.indices;l.push(R.startEllipsoidNormals.buffer),l.push(R.endEllipsoidNormals.buffer),l.push(R.startPositionAndHeights.buffer),l.push(R.startFaceNormalAndVertexCornerIds.buffer),l.push(R.endPositionAndHeights.buffer),l.push(R.endFaceNormalAndHalfWidths.buffer),l.push(R.vertexBatchIds.buffer),l.push(W.buffer);let z={indexDatatype:2===W.BYTES_PER_ELEMENT?r.IndexDatatype.UNSIGNED_SHORT:r.IndexDatatype.UNSIGNED_INT,startEllipsoidNormals:R.startEllipsoidNormals.buffer,endEllipsoidNormals:R.endEllipsoidNormals.buffer,startPositionAndHeights:R.startPositionAndHeights.buffer,startFaceNormalAndVertexCornerIds:R.startFaceNormalAndVertexCornerIds.buffer,endPositionAndHeights:R.endPositionAndHeights.buffer,endFaceNormalAndHalfWidths:R.endFaceNormalAndHalfWidths.buffer,vertexBatchIds:R.vertexBatchIds.buffer,indices:W.buffer};if(i.keepDecodedPositions){let e=function(e){let t=e.length,a=new Uint32Array(t+1),r=0;for(let s=0;s<t;++s)a[s]=r,r+=e[s];return a[t]=r,a}(c);l.push(U.buffer,e.buffer),z=a.combine(z,{decodedPositions:U.buffer,decodedPositionOffsets:e.buffer})}return z})});