define(["./defaultValue-f6d5e6da","./Matrix3-81054f0f","./ArcType-26a3f38d","./arrayRemoveDuplicates-9b636830","./Transforms-fce95115","./Color-7d827393","./ComponentDatatype-ab629b88","./GeometryAttribute-81ff775c","./GeometryAttributes-1e4ddcd2","./IndexDatatype-d3db4e7d","./Math-2ce22ee9","./PolylinePipeline-8495667b","./VertexFormat-fbdec922","./Matrix2-413c4048","./RuntimeError-9b4ce3fb","./combine-0c102d93","./WebGLConstants-7f557f93","./EllipsoidGeodesic-2723ab86","./EllipsoidRhumbLine-77eff028","./IntersectionTests-357c3d7f","./Plane-6add0ae1"],function(e,t,r,o,a,n,i,l,s,p,d,c,u,y,f,m,h,C,g,_,A){"use strict";let E=[];function b(o){let a=(o=e.defaultValue(o,e.defaultValue.EMPTY_OBJECT)).positions,i=o.colors,l=e.defaultValue(o.width,1),s=e.defaultValue(o.colorsPerVertex,!1);this._positions=a,this._colors=i,this._width=l,this._colorsPerVertex=s,this._vertexFormat=u.VertexFormat.clone(e.defaultValue(o.vertexFormat,u.VertexFormat.DEFAULT)),this._arcType=e.defaultValue(o.arcType,r.ArcType.GEODESIC),this._granularity=e.defaultValue(o.granularity,d.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(o.ellipsoid,t.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";let p=1+a.length*t.Cartesian3.packedLength;p+=e.defined(i)?1+i.length*n.Color.packedLength:1,this.packedLength=p+t.Ellipsoid.packedLength+u.VertexFormat.packedLength+4}b.pack=function(r,o,a){let i;a=e.defaultValue(a,0);let l=r._positions,s=l.length;for(o[a++]=s,i=0;i<s;++i,a+=t.Cartesian3.packedLength)t.Cartesian3.pack(l[i],o,a);let p=r._colors;for(s=e.defined(p)?p.length:0,o[a++]=s,i=0;i<s;++i,a+=n.Color.packedLength)n.Color.pack(p[i],o,a);return t.Ellipsoid.pack(r._ellipsoid,o,a),a+=t.Ellipsoid.packedLength,u.VertexFormat.pack(r._vertexFormat,o,a),a+=u.VertexFormat.packedLength,o[a++]=r._width,o[a++]=r._colorsPerVertex?1:0,o[a++]=r._arcType,o[a]=r._granularity,o};let P=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),x=new u.VertexFormat,T={positions:void 0,colors:void 0,ellipsoid:P,vertexFormat:x,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};b.unpack=function(r,o,a){let i;o=e.defaultValue(o,0);let l=r[o++],s=Array(l);for(i=0;i<l;++i,o+=t.Cartesian3.packedLength)s[i]=t.Cartesian3.unpack(r,o);l=r[o++];let p=l>0?Array(l):void 0;for(i=0;i<l;++i,o+=n.Color.packedLength)p[i]=n.Color.unpack(r,o);let d=t.Ellipsoid.unpack(r,o,P);o+=t.Ellipsoid.packedLength;let c=u.VertexFormat.unpack(r,o,x);o+=u.VertexFormat.packedLength;let y=r[o++],f=1===r[o++],m=r[o++],h=r[o];return e.defined(a)?(a._positions=s,a._colors=p,a._ellipsoid=t.Ellipsoid.clone(d,a._ellipsoid),a._vertexFormat=u.VertexFormat.clone(c,a._vertexFormat),a._width=y,a._colorsPerVertex=f,a._arcType=m,a._granularity=h,a):(T.positions=s,T.colors=p,T.width=y,T.colorsPerVertex=f,T.arcType=m,T.granularity=h,new b(T))};let w=new t.Cartesian3,D=new t.Cartesian3,k=new t.Cartesian3,V=new t.Cartesian3;return b.createGeometry=function(u){let y,f,m;let h=u._width,C=u._vertexFormat,g=u._colors,_=u._colorsPerVertex,A=u._arcType,b=u._granularity,P=u._ellipsoid,x=[],T=o.arrayRemoveDuplicates(u._positions,t.Cartesian3.equalsEpsilon,!1,x);if(e.defined(g)&&x.length>0){let e=0,t=x[0];g=g.filter(function(r,o){return!(_?o===t||0===o&&1===t:o+1===t)||(t=x[++e],!1)})}let v=T.length;if(v<2||h<=0)return;if(A===r.ArcType.GEODESIC||A===r.ArcType.RHUMB){let t,o;A===r.ArcType.GEODESIC?(t=d.CesiumMath.chordLength(b,P.maximumRadius),o=c.PolylinePipeline.numberOfPoints):(t=b,o=c.PolylinePipeline.numberOfPointsRhumbLine);let a=c.PolylinePipeline.extractHeights(T,P);if(e.defined(g)){let e=1;for(y=0;y<v-1;++y)e+=o(T[y],T[y+1],t);let r=Array(e),a=0;for(y=0;y<v-1;++y){let i=T[y],l=T[y+1],s=g[y],p=o(i,l,t);if(_&&y<e){let e=function(e,t,r,o,a){let i;let l=E;l.length=a;let s=r.red,p=r.green,d=r.blue,c=r.alpha,u=o.red,y=o.green,f=o.blue,m=o.alpha;if(n.Color.equals(r,o)){for(i=0;i<a;i++)l[i]=n.Color.clone(r);return l}let h=(u-s)/a,C=(y-p)/a,g=(f-d)/a,_=(m-c)/a;for(i=0;i<a;i++)l[i]=new n.Color(s+i*h,p+i*C,d+i*g,c+i*_);return l}(0,0,s,g[y+1],p),t=e.length;for(f=0;f<t;++f)r[a++]=e[f]}else for(f=0;f<p;++f)r[a++]=n.Color.clone(s)}r[a]=n.Color.clone(g[g.length-1]),g=r,E.length=0}T=A===r.ArcType.GEODESIC?c.PolylinePipeline.generateCartesianArc({positions:T,minDistance:t,ellipsoid:P,height:a}):c.PolylinePipeline.generateCartesianRhumbArc({positions:T,granularity:t,ellipsoid:P,height:a})}v=T.length;let L=4*v-4,F=new Float64Array(3*L),G=new Float64Array(3*L),O=new Float64Array(3*L),R=new Float32Array(2*L),I=C.st?new Float32Array(2*L):void 0,S=e.defined(g)?new Uint8Array(4*L):void 0,B,M=0,U=0,N=0,H=0;for(f=0;f<v;++f){let r,o;0===f?(B=w,t.Cartesian3.subtract(T[0],T[1],B),t.Cartesian3.add(T[0],B,B)):B=T[f-1],t.Cartesian3.clone(B,k),t.Cartesian3.clone(T[f],D),f===v-1?(B=w,t.Cartesian3.subtract(T[v-1],T[v-2],B),t.Cartesian3.add(T[v-1],B,B)):B=T[f+1],t.Cartesian3.clone(B,V),e.defined(S)&&(r=0===f||_?g[f]:g[f-1],f!==v-1&&(o=g[f]));let a=f===v-1?2:4;for(m=0===f?2:0;m<a;++m){t.Cartesian3.pack(D,F,M),t.Cartesian3.pack(k,G,M),t.Cartesian3.pack(V,O,M),M+=3;let a=m-2<0?-1:1;if(R[U++]=m%2*2-1,R[U++]=a*h,C.st&&(I[N++]=f/(v-1),I[N++]=Math.max(R[U-2],0)),e.defined(S)){let e=m<2?r:o;S[H++]=n.Color.floatToByte(e.red),S[H++]=n.Color.floatToByte(e.green),S[H++]=n.Color.floatToByte(e.blue),S[H++]=n.Color.floatToByte(e.alpha)}}}let W=new s.GeometryAttributes;W.position=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:F}),W.prevPosition=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G}),W.nextPosition=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:O}),W.expandAndWidth=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:R}),C.st&&(W.st=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:I})),e.defined(S)&&(W.color=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:S,normalize:!0}));let Y=p.IndexDatatype.createTypedArray(L,6*v-6),q=0,z=0,J=v-1;for(f=0;f<J;++f)Y[z++]=q,Y[z++]=q+2,Y[z++]=q+1,Y[z++]=q+1,Y[z++]=q+2,Y[z++]=q+3,q+=4;return new l.Geometry({attributes:W,indices:Y,primitiveType:l.PrimitiveType.TRIANGLES,boundingSphere:a.BoundingSphere.fromPoints(T),geometryType:l.GeometryType.POLYLINES})},function(r,o){return e.defined(o)&&(r=b.unpack(r,o)),r._ellipsoid=t.Ellipsoid.clone(r._ellipsoid),b.createGeometry(r)}});