define(["./arrayRemoveDuplicates-9b636830","./Transforms-fce95115","./Matrix3-81054f0f","./ComponentDatatype-ab629b88","./PolylineVolumeGeometryLibrary-2df3f067","./CorridorGeometryLibrary-28996bf3","./defaultValue-f6d5e6da","./GeometryAttribute-81ff775c","./GeometryAttributes-1e4ddcd2","./GeometryOffsetAttribute-2579b8d2","./IndexDatatype-d3db4e7d","./Math-2ce22ee9","./PolygonPipeline-61ca1579","./Matrix2-413c4048","./VertexFormat-fbdec922","./combine-0c102d93","./RuntimeError-9b4ce3fb","./WebGLConstants-7f557f93","./EllipsoidTangentPlane-82f2a887","./AxisAlignedBoundingBox-39ab50d0","./IntersectionTests-357c3d7f","./Plane-6add0ae1","./PolylinePipeline-8495667b","./EllipsoidGeodesic-2723ab86","./EllipsoidRhumbLine-77eff028"],function(t,e,r,a,i,o,n,l,s,d,u,m,f,y,p,c,g,h,b,C,A,_,w,v,T){"use strict";let G=new r.Cartesian3,E=new r.Cartesian3,V=new r.Cartesian3,x=new r.Cartesian3,L=new r.Cartesian3,P=new r.Cartesian3,F=new r.Cartesian3,N=new r.Cartesian3;function M(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function D(t,e,a,i,n,l){let s=t.normals,d=t.tangents,u=t.bitangents,m=r.Cartesian3.normalize(r.Cartesian3.cross(a,e,F),F);l.normal&&o.CorridorGeometryLibrary.addAttribute(s,e,i,n),l.tangent&&o.CorridorGeometryLibrary.addAttribute(d,m,i,n),l.bitangent&&o.CorridorGeometryLibrary.addAttribute(u,a,i,n)}function O(t,e,i){let d;let f=t.positions,y=t.corners,p=t.endPositions,c=t.lefts,g=t.normals,h=new s.GeometryAttributes,b,C,A,_=0,w=0,v=0;for(C=0;C<f.length;C+=2)A=f[C].length-3,_+=A,v+=2*A,w+=f[C+1].length-3;for(_+=3,w+=3,C=0;C<y.length;C++){b=y[C];let t=y[C].leftPositions;n.defined(t)?(_+=A=t.length,v+=A):(w+=A=y[C].rightPositions.length,v+=A)}let T=n.defined(p);T&&(_+=d=p[0].length-3,w+=d,d/=3,v+=6*d);let L=_+w,M=new Float64Array(L),O={normals:e.normal?new Float32Array(L):void 0,tangents:e.tangent?new Float32Array(L):void 0,bitangents:e.bitangent?new Float32Array(L):void 0},I,S,R,k,H,z,B=0,U=L-1,Y=G,W=E,q=d/2,J=u.IndexDatatype.createTypedArray(L/3,v),j=0;if(T){z=V,H=x;let t=p[0];for(Y=r.Cartesian3.fromArray(g,0,Y),W=r.Cartesian3.fromArray(c,0,W),C=0;C<q;C++)z=r.Cartesian3.fromArray(t,3*(q-1-C),z),H=r.Cartesian3.fromArray(t,3*(q+C),H),o.CorridorGeometryLibrary.addAttribute(M,H,B),o.CorridorGeometryLibrary.addAttribute(M,z,void 0,U),D(O,Y,W,B,U,e),k=(S=B/3)+1,R=(I=(U-2)/3)-1,J[j++]=I,J[j++]=S,J[j++]=R,J[j++]=R,J[j++]=S,J[j++]=k,B+=3,U-=3}let K,Q,X=0,Z=0,$=f[X++],tt=f[X++];for(M.set($,B),M.set(tt,U-tt.length+1),W=r.Cartesian3.fromArray(c,Z,W),A=tt.length-3,C=0;C<A;C+=3)K=i.geodeticSurfaceNormal(r.Cartesian3.fromArray($,C,F),F),Q=i.geodeticSurfaceNormal(r.Cartesian3.fromArray(tt,A-C,N),N),D(O,Y=r.Cartesian3.normalize(r.Cartesian3.add(K,Q,Y),Y),W,B,U,e),k=(S=B/3)+1,R=(I=(U-2)/3)-1,J[j++]=I,J[j++]=S,J[j++]=R,J[j++]=R,J[j++]=S,J[j++]=k,B+=3,U-=3;for(K=i.geodeticSurfaceNormal(r.Cartesian3.fromArray($,A,F),F),Q=i.geodeticSurfaceNormal(r.Cartesian3.fromArray(tt,A,N),N),Y=r.Cartesian3.normalize(r.Cartesian3.add(K,Q,Y),Y),Z+=3,C=0;C<y.length;C++){let t;b=y[C];let a=b.leftPositions,l=b.rightPositions,s,d,u=P,m=V,p=x;if(Y=r.Cartesian3.fromArray(g,Z,Y),n.defined(a)){for(D(O,Y,W,void 0,U,e),U-=3,s=k,d=R,t=0;t<a.length/3;t++)u=r.Cartesian3.fromArray(a,3*t,u),J[j++]=s,J[j++]=d-t-1,J[j++]=d-t,o.CorridorGeometryLibrary.addAttribute(M,u,void 0,U),m=r.Cartesian3.fromArray(M,3*(d-t-1),m),p=r.Cartesian3.fromArray(M,3*s,p),D(O,Y,W=r.Cartesian3.normalize(r.Cartesian3.subtract(m,p,W),W),void 0,U,e),U-=3;u=r.Cartesian3.fromArray(M,3*s,u),m=r.Cartesian3.subtract(r.Cartesian3.fromArray(M,3*d,m),u,m),p=r.Cartesian3.subtract(r.Cartesian3.fromArray(M,3*(d-t),p),u,p),D(O,Y,W=r.Cartesian3.normalize(r.Cartesian3.add(m,p,W),W),B,void 0,e),B+=3}else{for(D(O,Y,W,B,void 0,e),B+=3,s=R,d=k,t=0;t<l.length/3;t++)u=r.Cartesian3.fromArray(l,3*t,u),J[j++]=s,J[j++]=d+t,J[j++]=d+t+1,o.CorridorGeometryLibrary.addAttribute(M,u,B),m=r.Cartesian3.fromArray(M,3*s,m),p=r.Cartesian3.fromArray(M,3*(d+t),p),D(O,Y,W=r.Cartesian3.normalize(r.Cartesian3.subtract(m,p,W),W),B,void 0,e),B+=3;u=r.Cartesian3.fromArray(M,3*s,u),m=r.Cartesian3.subtract(r.Cartesian3.fromArray(M,3*(d+t),m),u,m),p=r.Cartesian3.subtract(r.Cartesian3.fromArray(M,3*d,p),u,p),D(O,Y,W=r.Cartesian3.normalize(r.Cartesian3.negate(r.Cartesian3.add(p,m,W),W),W),void 0,U,e),U-=3}for($=f[X++],tt=f[X++],$.splice(0,3),tt.splice(tt.length-3,3),M.set($,B),M.set(tt,U-tt.length+1),A=tt.length-3,Z+=3,W=r.Cartesian3.fromArray(c,Z,W),t=0;t<tt.length;t+=3)K=i.geodeticSurfaceNormal(r.Cartesian3.fromArray($,t,F),F),Q=i.geodeticSurfaceNormal(r.Cartesian3.fromArray(tt,A-t,N),N),D(O,Y=r.Cartesian3.normalize(r.Cartesian3.add(K,Q,Y),Y),W,B,U,e),S=(k=B/3)-1,I=(R=(U-2)/3)+1,J[j++]=I,J[j++]=S,J[j++]=R,J[j++]=R,J[j++]=S,J[j++]=k,B+=3,U-=3;B-=3,U+=3}if(D(O,Y=r.Cartesian3.fromArray(g,g.length-3,Y),W,B,U,e),T){B+=3,U-=3,z=V,H=x;let t=p[1];for(C=0;C<q;C++)z=r.Cartesian3.fromArray(t,3*(d-C-1),z),H=r.Cartesian3.fromArray(t,3*C,H),o.CorridorGeometryLibrary.addAttribute(M,z,void 0,U),o.CorridorGeometryLibrary.addAttribute(M,H,B),D(O,Y,W,B,U,e),S=(k=B/3)-1,I=(R=(U-2)/3)+1,J[j++]=I,J[j++]=S,J[j++]=R,J[j++]=R,J[j++]=S,J[j++]=k,B+=3,U-=3}if(h.position=new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:M}),e.st){let t=new Float32Array(L/3*2),e,r,i=0;if(T){let a;_/=3,w/=3;let o=Math.PI/(d+1);r=1/(_-d+1),e=1/(w-d+1);let n=d/2;for(C=n+1;C<d+1;C++)a=m.CesiumMath.PI_OVER_TWO+o*C,t[i++]=e*(1+Math.cos(a)),t[i++]=.5*(1+Math.sin(a));for(C=1;C<w-d+1;C++)t[i++]=C*e,t[i++]=0;for(C=d;C>n;C--)a=m.CesiumMath.PI_OVER_TWO-C*o,t[i++]=1-e*(1+Math.cos(a)),t[i++]=.5*(1+Math.sin(a));for(C=n;C>0;C--)a=m.CesiumMath.PI_OVER_TWO-o*C,t[i++]=1-r*(1+Math.cos(a)),t[i++]=.5*(1+Math.sin(a));for(C=_-d;C>0;C--)t[i++]=C*r,t[i++]=1;for(C=1;C<n+1;C++)a=m.CesiumMath.PI_OVER_TWO+o*C,t[i++]=r*(1+Math.cos(a)),t[i++]=.5*(1+Math.sin(a))}else{for(_/=3,w/=3,r=1/(_-1),e=1/(w-1),C=0;C<w;C++)t[i++]=C*e,t[i++]=0;for(C=_;C>0;C--)t[i++]=(C-1)*r,t[i++]=1}h.st=new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:t})}return e.normal&&(h.normal=new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:O.normals})),e.tangent&&(h.tangent=new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:O.tangents})),e.bitangent&&(h.bitangent=new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:O.bitangents})),{attributes:h,indices:J}}function I(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(let a=3;a<t.length;a+=3){let i=t[a],o=t[a+1],n=t[a+2];r[e++]=i,r[e++]=o,r[e++]=n,r[e++]=i,r[e++]=o,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}let S=new r.Cartesian3,R=new r.Cartesian3,k=new r.Cartographic;function H(t,e,a,i,o,n){let l=r.Cartesian3.subtract(e,t,S);r.Cartesian3.normalize(l,l);let s=a.geodeticSurfaceNormal(t,R),d=r.Cartesian3.cross(l,s,S);r.Cartesian3.multiplyByScalar(d,i,d);let u=o.latitude,m=o.longitude,f=n.latitude,y=n.longitude;r.Cartesian3.add(t,d,R),a.cartesianToCartographic(R,k);let p=k.latitude,c=k.longitude;u=Math.min(u,p),m=Math.min(m,c),f=Math.max(f,p),y=Math.max(y,c),r.Cartesian3.subtract(t,d,R),a.cartesianToCartographic(R,k),p=k.latitude,c=k.longitude,u=Math.min(u,p),m=Math.min(m,c),f=Math.max(f,p),y=Math.max(y,c),o.latitude=u,o.longitude=m,n.latitude=f,n.longitude=y}let z=new r.Cartesian3,B=new r.Cartesian3,U=new r.Cartographic,Y=new r.Cartographic;function W(e,a,o,l,s){let d,u;e=M(e,a);let m=t.arrayRemoveDuplicates(e,r.Cartesian3.equalsEpsilon),f=m.length;if(f<2||o<=0)return new y.Rectangle;let p=.5*o;if(U.latitude=Number.POSITIVE_INFINITY,U.longitude=Number.POSITIVE_INFINITY,Y.latitude=Number.NEGATIVE_INFINITY,Y.longitude=Number.NEGATIVE_INFINITY,l===i.CornerType.ROUNDED){let t=m[0];r.Cartesian3.subtract(t,m[1],z),r.Cartesian3.normalize(z,z),r.Cartesian3.multiplyByScalar(z,p,z),r.Cartesian3.add(t,z,B),a.cartesianToCartographic(B,k),d=k.latitude,u=k.longitude,U.latitude=Math.min(U.latitude,d),U.longitude=Math.min(U.longitude,u),Y.latitude=Math.max(Y.latitude,d),Y.longitude=Math.max(Y.longitude,u)}for(let t=0;t<f-1;++t)H(m[t],m[t+1],a,p,U,Y);let c=m[f-1];r.Cartesian3.subtract(c,m[f-2],z),r.Cartesian3.normalize(z,z),r.Cartesian3.multiplyByScalar(z,p,z),r.Cartesian3.add(c,z,B),H(c,B,a,p,U,Y),l===i.CornerType.ROUNDED&&(a.cartesianToCartographic(B,k),d=k.latitude,u=k.longitude,U.latitude=Math.min(U.latitude,d),U.longitude=Math.min(U.longitude,u),Y.latitude=Math.max(Y.latitude,d),Y.longitude=Math.max(Y.longitude,u));let g=n.defined(s)?s:new y.Rectangle;return g.north=Y.latitude,g.south=U.latitude,g.east=Y.longitude,g.west=U.longitude,g}function q(t){let e=(t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT)).positions,a=t.width,o=n.defaultValue(t.height,0),l=n.defaultValue(t.extrudedHeight,o);this._positions=e,this._ellipsoid=r.Ellipsoid.clone(n.defaultValue(t.ellipsoid,r.Ellipsoid.WGS84)),this._vertexFormat=p.VertexFormat.clone(n.defaultValue(t.vertexFormat,p.VertexFormat.DEFAULT)),this._width=a,this._height=Math.max(o,l),this._extrudedHeight=Math.min(o,l),this._cornerType=n.defaultValue(t.cornerType,i.CornerType.ROUNDED),this._granularity=n.defaultValue(t.granularity,m.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=n.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*r.Cartesian3.packedLength+r.Ellipsoid.packedLength+p.VertexFormat.packedLength+7}q.pack=function(t,e,a){a=n.defaultValue(a,0);let i=t._positions,o=i.length;e[a++]=o;for(let t=0;t<o;++t,a+=r.Cartesian3.packedLength)r.Cartesian3.pack(i[t],e,a);return r.Ellipsoid.pack(t._ellipsoid,e,a),a+=r.Ellipsoid.packedLength,p.VertexFormat.pack(t._vertexFormat,e,a),a+=p.VertexFormat.packedLength,e[a++]=t._width,e[a++]=t._height,e[a++]=t._extrudedHeight,e[a++]=t._cornerType,e[a++]=t._granularity,e[a++]=t._shadowVolume?1:0,e[a]=n.defaultValue(t._offsetAttribute,-1),e};let J=r.Ellipsoid.clone(r.Ellipsoid.UNIT_SPHERE),j=new p.VertexFormat,K={positions:void 0,ellipsoid:J,vertexFormat:j,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return q.unpack=function(t,e,a){e=n.defaultValue(e,0);let i=t[e++],o=Array(i);for(let a=0;a<i;++a,e+=r.Cartesian3.packedLength)o[a]=r.Cartesian3.unpack(t,e);let l=r.Ellipsoid.unpack(t,e,J);e+=r.Ellipsoid.packedLength;let s=p.VertexFormat.unpack(t,e,j);e+=p.VertexFormat.packedLength;let d=t[e++],u=t[e++],m=t[e++],f=t[e++],y=t[e++],c=1===t[e++],g=t[e];return n.defined(a)?(a._positions=o,a._ellipsoid=r.Ellipsoid.clone(l,a._ellipsoid),a._vertexFormat=p.VertexFormat.clone(s,a._vertexFormat),a._width=d,a._height=u,a._extrudedHeight=m,a._cornerType=f,a._granularity=y,a._shadowVolume=c,a._offsetAttribute=-1===g?void 0:g,a):(K.positions=o,K.width=d,K.height=u,K.extrudedHeight=m,K.cornerType=f,K.granularity=y,K.shadowVolume=c,K.offsetAttribute=-1===g?void 0:g,new q(K))},q.computeRectangle=function(t,e){let a=(t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT)).positions,o=t.width;return W(a,n.defaultValue(t.ellipsoid,r.Ellipsoid.WGS84),o,n.defaultValue(t.cornerType,i.CornerType.ROUNDED),e)},q.createGeometry=function(i){let s,y=i._positions,c=i._width,g=i._ellipsoid;y=M(y,g);let h=t.arrayRemoveDuplicates(y,r.Cartesian3.equalsEpsilon);if(h.length<2||c<=0)return;let b=i._height,C=i._extrudedHeight,A=!m.CesiumMath.equalsEpsilon(b,C,0,m.CesiumMath.EPSILON2),_=i._vertexFormat,w={ellipsoid:g,positions:h,width:c,cornerType:i._cornerType,granularity:i._granularity,saveAttributes:!0};if(A)w.height=b,w.extrudedHeight=C,w.shadowVolume=i._shadowVolume,w.offsetAttribute=i._offsetAttribute,s=function(t,e){let i=new p.VertexFormat({position:e.position,normal:e.normal||e.bitangent||t.shadowVolume,tangent:e.tangent,bitangent:e.normal||e.bitangent,st:e.st}),s=t.ellipsoid,m=O(o.CorridorGeometryLibrary.computePositions(t),i,s),y=t.height,c=t.extrudedHeight,g=m.attributes,h=m.indices,b=g.position.values,C=b.length,A=new Float64Array(6*C),_=new Float64Array(C);_.set(b);let w,v=new Float64Array(4*C);v=I(b=f.PolygonPipeline.scaleToGeodeticHeight(b,y,s),0,v),v=I(_=f.PolygonPipeline.scaleToGeodeticHeight(_,c,s),2*C,v),A.set(b),A.set(_,C),A.set(v,2*C),g.position.values=A,g=function(t,e){let a,i,n;if(!(e.normal||e.tangent||e.bitangent||e.st))return t;let l=t.position.values;(e.normal||e.bitangent)&&(a=t.normal.values,i=t.bitangent.values);let s=t.position.values.length/18,d=3*s,u=2*s,m=2*d;if(e.normal||e.bitangent||e.tangent){let s=e.normal?new Float32Array(6*d):void 0,u=e.tangent?new Float32Array(6*d):void 0,f=e.bitangent?new Float32Array(6*d):void 0,y=G,p=E,c=V,g=x,h=L,b=P,C=m;for(n=0;n<d;n+=3){let t=C+m;y=r.Cartesian3.fromArray(l,n,y),p=r.Cartesian3.fromArray(l,n+d,p),c=r.Cartesian3.fromArray(l,(n+3)%d,c),p=r.Cartesian3.subtract(p,y,p),c=r.Cartesian3.subtract(c,y,c),g=r.Cartesian3.normalize(r.Cartesian3.cross(p,c,g),g),e.normal&&(o.CorridorGeometryLibrary.addAttribute(s,g,t),o.CorridorGeometryLibrary.addAttribute(s,g,t+3),o.CorridorGeometryLibrary.addAttribute(s,g,C),o.CorridorGeometryLibrary.addAttribute(s,g,C+3)),(e.tangent||e.bitangent)&&(b=r.Cartesian3.fromArray(a,n,b),e.bitangent&&(o.CorridorGeometryLibrary.addAttribute(f,b,t),o.CorridorGeometryLibrary.addAttribute(f,b,t+3),o.CorridorGeometryLibrary.addAttribute(f,b,C),o.CorridorGeometryLibrary.addAttribute(f,b,C+3)),e.tangent&&(h=r.Cartesian3.normalize(r.Cartesian3.cross(b,g,h),h),o.CorridorGeometryLibrary.addAttribute(u,h,t),o.CorridorGeometryLibrary.addAttribute(u,h,t+3),o.CorridorGeometryLibrary.addAttribute(u,h,C),o.CorridorGeometryLibrary.addAttribute(u,h,C+3))),C+=6}if(e.normal){for(s.set(a),n=0;n<d;n+=3)s[n+d]=-a[n],s[n+d+1]=-a[n+1],s[n+d+2]=-a[n+2];t.normal.values=s}else t.normal=void 0;if(e.bitangent?(f.set(i),f.set(i,d),t.bitangent.values=f):t.bitangent=void 0,e.tangent){let e=t.tangent.values;u.set(e),u.set(e,d),t.tangent.values=u}}if(e.st){let e=t.st.values,r=new Float32Array(6*u);r.set(e),r.set(e,u);let a=2*u;for(let t=0;t<2;t++){for(r[a++]=e[0],r[a++]=e[1],n=2;n<u;n+=2){let t=e[n],i=e[n+1];r[a++]=t,r[a++]=i,r[a++]=t,r[a++]=i}r[a++]=e[0],r[a++]=e[1]}t.st.values=r}return t}(g,e);let T=C/3;if(t.shadowVolume){let t=g.normal.values;C=t.length;let r=new Float32Array(6*C);for(w=0;w<C;w++)t[w]=-t[w];r.set(t,C),r=I(t,4*C,r),g.extrudeDirection=new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:r}),e.normal||(g.normal=void 0)}if(n.defined(t.offsetAttribute)){let e=new Uint8Array(6*T);if(t.offsetAttribute===d.GeometryOffsetAttribute.TOP)e=e.fill(1,0,T).fill(1,2*T,4*T);else{let r=t.offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1;e=e.fill(r)}g.applyOffset=new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}let F=h.length,N=T+T,M=u.IndexDatatype.createTypedArray(A.length/3,2*F+3*N);M.set(h);let D,S,R,k,H=F;for(w=0;w<F;w+=3){let t=h[w],e=h[w+1],r=h[w+2];M[H++]=r+T,M[H++]=e+T,M[H++]=t+T}for(w=0;w<N;w+=2)S=(D=w+N)+N,R=D+1,k=S+1,M[H++]=D,M[H++]=S,M[H++]=R,M[H++]=R,M[H++]=S,M[H++]=k;return{attributes:g,indices:M}}(w,_);else if((s=O(o.CorridorGeometryLibrary.computePositions(w),_,g)).attributes.position.values=f.PolygonPipeline.scaleToGeodeticHeight(s.attributes.position.values,b,g),n.defined(i._offsetAttribute)){let t=i._offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1,e=s.attributes.position.values.length,r=new Uint8Array(e/3).fill(t);s.attributes.applyOffset=new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}let v=s.attributes,T=e.BoundingSphere.fromVertices(v.position.values,void 0,3);return _.position||(s.attributes.position.values=void 0),new l.Geometry({attributes:v,indices:s.indices,primitiveType:l.PrimitiveType.TRIANGLES,boundingSphere:T,offsetAttribute:i._offsetAttribute})},q.createShadowVolume=function(t,e,r){let a=t._granularity,i=t._ellipsoid,o=e(a,i),n=r(a,i);return new q({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:a,extrudedHeight:o,height:n,vertexFormat:p.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(q.prototype,{rectangle:{get:function(){return n.defined(this._rectangle)||(this._rectangle=W(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,e){return n.defined(e)&&(t=q.unpack(t,e)),t._ellipsoid=r.Ellipsoid.clone(t._ellipsoid),q.createGeometry(t)}});