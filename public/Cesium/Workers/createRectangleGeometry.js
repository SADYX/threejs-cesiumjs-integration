define(["./defaultValue-f6d5e6da","./Matrix3-81054f0f","./Matrix2-413c4048","./Transforms-fce95115","./ComponentDatatype-ab629b88","./GeometryAttribute-81ff775c","./GeometryAttributes-1e4ddcd2","./GeometryInstance-0318e0cd","./GeometryOffsetAttribute-2579b8d2","./GeometryPipeline-e049e700","./IndexDatatype-d3db4e7d","./Math-2ce22ee9","./PolygonPipeline-61ca1579","./RectangleGeometryLibrary-a0a06d23","./VertexFormat-fbdec922","./RuntimeError-9b4ce3fb","./combine-0c102d93","./WebGLConstants-7f557f93","./AttributeCompression-48e336db","./EncodedCartesian3-5e2017ab","./IntersectionTests-357c3d7f","./Plane-6add0ae1","./EllipsoidRhumbLine-77eff028"],function(t,e,a,n,r,i,o,l,s,u,c,m,d,p,g,y,f,h,b,_,A,x,w){"use strict";let C=new e.Cartesian3,v=new e.Cartesian3,R=new e.Cartesian3,E=new e.Cartesian3,G=new a.Rectangle,F=new a.Cartesian2,P=new n.BoundingSphere,V=new n.BoundingSphere;function L(t,e){let a=new i.Geometry({attributes:new o.GeometryAttributes,primitiveType:i.PrimitiveType.TRIANGLES});return a.attributes.position=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(a.attributes.normal=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(a.attributes.tangent=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(a.attributes.bitangent=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.bitangents})),a}let D=new e.Cartesian3,M=new e.Cartesian3;function T(t,a){let n=t._vertexFormat,o=t._ellipsoid,l=a.height,s=a.width,u=a.northCap,m=a.southCap,d=0,g=l,y=l,f=0;u&&(d=1,y-=1,f+=1),m&&(g-=1,y-=1,f+=1),f+=s*y;let h=n.position?new Float64Array(3*f):void 0,b=n.st?new Float32Array(2*f):void 0,_=0,A=0,x=Number.MAX_VALUE,w=Number.MAX_VALUE,G=-Number.MAX_VALUE,P=-Number.MAX_VALUE;for(let t=d;t<g;++t)for(let e=0;e<s;++e)p.RectangleGeometryLibrary.computePosition(a,o,n.st,t,e,C,F),h[_++]=C.x,h[_++]=C.y,h[_++]=C.z,n.st&&(b[A++]=F.x,b[A++]=F.y,x=Math.min(x,F.x),w=Math.min(w,F.y),G=Math.max(G,F.x),P=Math.max(P,F.y));if(u&&(p.RectangleGeometryLibrary.computePosition(a,o,n.st,0,0,C,F),h[_++]=C.x,h[_++]=C.y,h[_++]=C.z,n.st&&(b[A++]=F.x,b[A++]=F.y,x=F.x,w=F.y,G=F.x,P=F.y)),m&&(p.RectangleGeometryLibrary.computePosition(a,o,n.st,l-1,0,C,F),h[_++]=C.x,h[_++]=C.y,h[_]=C.z,n.st&&(b[A++]=F.x,b[A]=F.y,x=Math.min(x,F.x),w=Math.min(w,F.y),G=Math.max(G,F.x),P=Math.max(P,F.y))),n.st&&(x<0||w<0||G>1||P>1))for(let t=0;t<b.length;t+=2)b[t]=(b[t]-x)/(G-x),b[t+1]=(b[t+1]-w)/(P-w);let V=function(t,a,n,r){let i=t.length,o=a.normal?new Float32Array(i):void 0,l=a.tangent?new Float32Array(i):void 0,s=a.bitangent?new Float32Array(i):void 0,u=0,c=v;if(a.normal||a.tangent||a.bitangent)for(let m=0;m<i;m+=3){let i=e.Cartesian3.fromArray(t,m,C),d=u+1,p=u+2;c=n.geodeticSurfaceNormal(i,c),(a.tangent||a.bitangent)&&(e.Cartesian3.cross(e.Cartesian3.UNIT_Z,c,R),e.Matrix3.multiplyByVector(r,R,R),e.Cartesian3.normalize(R,R),a.bitangent&&e.Cartesian3.normalize(e.Cartesian3.cross(c,R,E),E)),a.normal&&(o[u]=c.x,o[d]=c.y,o[p]=c.z),a.tangent&&(l[u]=R.x,l[d]=R.y,l[p]=R.z),a.bitangent&&(s[u]=E.x,s[d]=E.y,s[p]=E.z),u+=3}return L(a,{positions:t,normals:o,tangents:l,bitangents:s})}(h,n,o,a.tangentRotationMatrix),D=6*(s-1)*(y-1);u&&(D+=3*(s-1)),m&&(D+=3*(s-1));let M=c.IndexDatatype.createTypedArray(f,D),T,O=0,N=0;for(T=0;T<y-1;++T){for(let t=0;t<s-1;++t){let t=O,e=t+s,a=e+1,n=t+1;M[N++]=t,M[N++]=e,M[N++]=n,M[N++]=n,M[N++]=e,M[N++]=a,++O}++O}if(u||m){let t,e,a=f-1,n=f-1;if(u&&m&&(a=f-2),O=0,u)for(T=0;T<s-1;T++)e=(t=O)+1,M[N++]=a,M[N++]=t,M[N++]=e,++O;if(m)for(O=(y-1)*s,T=0;T<s-1;T++)e=(t=O)+1,M[N++]=t,M[N++]=n,M[N++]=e,++O}return V.indices=M,n.st&&(V.attributes.st=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:b})),V}function O(t,e,a,n,r){return t[e++]=n[a],t[e++]=n[a+1],t[e++]=n[a+2],t[e++]=r[a],t[e++]=r[a+1],t[e]=r[a+2],t}function N(t,e,a,n){return t[e++]=n[a],t[e++]=n[a+1],t[e++]=n[a],t[e]=n[a+1],t}let S=new g.VertexFormat,I=[new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3],k=new e.Cartographic,H=new e.Cartographic;function z(t,e,n,r,i){if(0===n)return a.Rectangle.clone(t,i);let o=p.RectangleGeometryLibrary.computeOptions(t,e,n,0,G,k),l=o.height,s=o.width;return p.RectangleGeometryLibrary.computePosition(o,r,!1,0,0,I[0]),p.RectangleGeometryLibrary.computePosition(o,r,!1,0,s-1,I[1]),p.RectangleGeometryLibrary.computePosition(o,r,!1,l-1,0,I[2]),p.RectangleGeometryLibrary.computePosition(o,r,!1,l-1,s-1,I[3]),a.Rectangle.fromCartesianArray(I,r,i)}function B(n){let r=(n=t.defaultValue(n,t.defaultValue.EMPTY_OBJECT)).rectangle,i=t.defaultValue(n.height,0),o=t.defaultValue(n.extrudedHeight,i);this._rectangle=a.Rectangle.clone(r),this._granularity=t.defaultValue(n.granularity,m.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=e.Ellipsoid.clone(t.defaultValue(n.ellipsoid,e.Ellipsoid.WGS84)),this._surfaceHeight=Math.max(i,o),this._rotation=t.defaultValue(n.rotation,0),this._stRotation=t.defaultValue(n.stRotation,0),this._vertexFormat=g.VertexFormat.clone(t.defaultValue(n.vertexFormat,g.VertexFormat.DEFAULT)),this._extrudedHeight=Math.min(i,o),this._shadowVolume=t.defaultValue(n.shadowVolume,!1),this._workerName="createRectangleGeometry",this._offsetAttribute=n.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}B.packedLength=a.Rectangle.packedLength+e.Ellipsoid.packedLength+g.VertexFormat.packedLength+7,B.pack=function(n,r,i){return i=t.defaultValue(i,0),a.Rectangle.pack(n._rectangle,r,i),i+=a.Rectangle.packedLength,e.Ellipsoid.pack(n._ellipsoid,r,i),i+=e.Ellipsoid.packedLength,g.VertexFormat.pack(n._vertexFormat,r,i),i+=g.VertexFormat.packedLength,r[i++]=n._granularity,r[i++]=n._surfaceHeight,r[i++]=n._rotation,r[i++]=n._stRotation,r[i++]=n._extrudedHeight,r[i++]=n._shadowVolume?1:0,r[i]=t.defaultValue(n._offsetAttribute,-1),r};let U=new a.Rectangle,Y=e.Ellipsoid.clone(e.Ellipsoid.UNIT_SPHERE),q={rectangle:U,ellipsoid:Y,vertexFormat:S,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};B.unpack=function(n,r,i){r=t.defaultValue(r,0);let o=a.Rectangle.unpack(n,r,U);r+=a.Rectangle.packedLength;let l=e.Ellipsoid.unpack(n,r,Y);r+=e.Ellipsoid.packedLength;let s=g.VertexFormat.unpack(n,r,S);r+=g.VertexFormat.packedLength;let u=n[r++],c=n[r++],m=n[r++],d=n[r++],p=n[r++],y=1===n[r++],f=n[r];return t.defined(i)?(i._rectangle=a.Rectangle.clone(o,i._rectangle),i._ellipsoid=e.Ellipsoid.clone(l,i._ellipsoid),i._vertexFormat=g.VertexFormat.clone(s,i._vertexFormat),i._granularity=u,i._surfaceHeight=c,i._rotation=m,i._stRotation=d,i._extrudedHeight=p,i._shadowVolume=y,i._offsetAttribute=-1===f?void 0:f,i):(q.granularity=u,q.height=c,q.rotation=m,q.stRotation=d,q.extrudedHeight=p,q.shadowVolume=y,q.offsetAttribute=-1===f?void 0:f,new B(q))},B.computeRectangle=function(a,n){let r=(a=t.defaultValue(a,t.defaultValue.EMPTY_OBJECT)).rectangle,i=t.defaultValue(a.granularity,m.CesiumMath.RADIANS_PER_DEGREE),o=t.defaultValue(a.ellipsoid,e.Ellipsoid.WGS84);return z(r,i,t.defaultValue(a.rotation,0),o,n)};let X=new e.Matrix3,Q=new n.Quaternion,W=new e.Cartographic;B.createGeometry=function(o){let y,f;if(m.CesiumMath.equalsEpsilon(o._rectangle.north,o._rectangle.south,m.CesiumMath.EPSILON10)||m.CesiumMath.equalsEpsilon(o._rectangle.east,o._rectangle.west,m.CesiumMath.EPSILON10))return;let h=o._rectangle,b=o._ellipsoid,_=o._rotation,A=o._stRotation,x=o._vertexFormat,w=p.RectangleGeometryLibrary.computeOptions(h,o._granularity,_,A,G,k,H);if(0!==A||0!==_){let t=a.Rectangle.center(h,W),r=b.geodeticSurfaceNormalCartographic(t,D);n.Quaternion.fromAxisAngle(r,-A,Q),e.Matrix3.fromQuaternion(Q,X)}else e.Matrix3.clone(e.Matrix3.IDENTITY,X);let F=o._surfaceHeight,I=o._extrudedHeight,z=!m.CesiumMath.equalsEpsilon(F,I,0,m.CesiumMath.EPSILON2);if(w.lonScalar=1/o._rectangle.width,w.latScalar=1/o._rectangle.height,w.tangentRotationMatrix=X,h=o._rectangle,z){y=function(a,n){let o,p,y,f,h,b,_,A,x;let w=a._shadowVolume,G=a._offsetAttribute,F=a._vertexFormat,P=a._extrudedHeight,V=a._surfaceHeight,I=a._ellipsoid,k=n.height,H=n.width;if(w){let t=g.VertexFormat.clone(F,S);t.normal=!0,a._vertexFormat=t}let z=T(a,n);w&&(a._vertexFormat=F);let B=d.PolygonPipeline.scaleToGeodeticHeight(z.attributes.position.values,V,I,!1),U=(B=new Float64Array(B)).length,Y=2*U,q=new Float64Array(Y);q.set(B);let X=d.PolygonPipeline.scaleToGeodeticHeight(z.attributes.position.values,P,I);q.set(X,U),z.attributes.position.values=q;let Q=F.normal?new Float32Array(Y):void 0,W=F.tangent?new Float32Array(Y):void 0,J=F.bitangent?new Float32Array(Y):void 0,j=F.st?new Float32Array(Y/3*2):void 0;if(F.normal){for(y=z.attributes.normal.values,Q.set(y),o=0;o<U;o++)y[o]=-y[o];Q.set(y,U),z.attributes.normal.values=Q}if(w){y=z.attributes.normal.values,F.normal||(z.attributes.normal=void 0);let t=new Float32Array(Y);for(o=0;o<U;o++)y[o]=-y[o];t.set(y,U),z.attributes.extrudeDirection=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:t})}let Z=t.defined(G);if(Z){let t=U/3*2,e=new Uint8Array(t);G===s.GeometryOffsetAttribute.TOP?e=e.fill(1,0,t/2):(f=G===s.GeometryOffsetAttribute.NONE?0:1,e=e.fill(f)),z.attributes.applyOffset=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}if(F.tangent){let t=z.attributes.tangent.values;for(W.set(t),o=0;o<U;o++)t[o]=-t[o];W.set(t,U),z.attributes.tangent.values=W}if(F.bitangent){let t=z.attributes.bitangent.values;J.set(t),J.set(t,U),z.attributes.bitangent.values=J}F.st&&(p=z.attributes.st.values,j.set(p),j.set(p,U/3*2),z.attributes.st.values=j);let K=z.indices,$=K.length,tt=U/3,te=c.IndexDatatype.createTypedArray(Y/3,2*$);for(te.set(K),o=0;o<$;o+=3)te[o+$]=K[o+2]+tt,te[o+1+$]=K[o+1]+tt,te[o+2+$]=K[o]+tt;z.indices=te;let ta=n.northCap,tn=n.southCap,tr=k,ti=2,to=0,tl=4,ts=4;ta&&(ti-=1,tr-=1,to+=1,tl-=2,ts-=1),tn&&(ti-=1,tr-=1,to+=1,tl-=2,ts-=1),to+=ti*H+2*tr-tl;let tu=2*(to+ts),tc=new Float64Array(3*tu),tm=w?new Float32Array(3*tu):void 0,td=Z?new Uint8Array(tu):void 0,tp=F.st?new Float32Array(2*tu):void 0,tg=G===s.GeometryOffsetAttribute.TOP;Z&&!tg&&(f=G===s.GeometryOffsetAttribute.ALL?1:0,td=td.fill(f));let ty=0,tf=0,th=0,tb=0,t_=H*tr;for(o=0;o<t_;o+=H)tc=O(tc,ty,h=3*o,B,X),ty+=6,F.st&&(tp=N(tp,tf,2*o,p),tf+=4),w&&(th+=3,tm[th++]=y[h],tm[th++]=y[h+1],tm[th++]=y[h+2]),tg&&(td[tb++]=1,tb+=1);if(tn){let t=ta?t_+1:t_;for(h=3*t,o=0;o<2;o++)tc=O(tc,ty,h,B,X),ty+=6,F.st&&(tp=N(tp,tf,2*t,p),tf+=4),w&&(th+=3,tm[th++]=y[h],tm[th++]=y[h+1],tm[th++]=y[h+2]),tg&&(td[tb++]=1,tb+=1)}else for(o=t_-H;o<t_;o++)tc=O(tc,ty,h=3*o,B,X),ty+=6,F.st&&(tp=N(tp,tf,2*o,p),tf+=4),w&&(th+=3,tm[th++]=y[h],tm[th++]=y[h+1],tm[th++]=y[h+2]),tg&&(td[tb++]=1,tb+=1);for(o=t_-1;o>0;o-=H)tc=O(tc,ty,h=3*o,B,X),ty+=6,F.st&&(tp=N(tp,tf,2*o,p),tf+=4),w&&(th+=3,tm[th++]=y[h],tm[th++]=y[h+1],tm[th++]=y[h+2]),tg&&(td[tb++]=1,tb+=1);if(ta)for(h=3*t_,o=0;o<2;o++)tc=O(tc,ty,h,B,X),ty+=6,F.st&&(tp=N(tp,tf,2*t_,p),tf+=4),w&&(th+=3,tm[th++]=y[h],tm[th++]=y[h+1],tm[th++]=y[h+2]),tg&&(td[tb++]=1,tb+=1);else for(o=H-1;o>=0;o--)tc=O(tc,ty,h=3*o,B,X),ty+=6,F.st&&(tp=N(tp,tf,2*o,p),tf+=4),w&&(th+=3,tm[th++]=y[h],tm[th++]=y[h+1],tm[th++]=y[h+2]),tg&&(td[tb++]=1,tb+=1);let tA=function(t,a,n){let r=t.length,i=a.normal?new Float32Array(r):void 0,o=a.tangent?new Float32Array(r):void 0,l=a.bitangent?new Float32Array(r):void 0,s=0,u=0,c=0,d=!0,p=E,g=R,y=v;if(a.normal||a.tangent||a.bitangent)for(let f=0;f<r;f+=6){let h=e.Cartesian3.fromArray(t,f,C),b=e.Cartesian3.fromArray(t,(f+6)%r,D);if(d){let a=e.Cartesian3.fromArray(t,(f+3)%r,M);e.Cartesian3.subtract(b,h,b),e.Cartesian3.subtract(a,h,a),y=e.Cartesian3.normalize(e.Cartesian3.cross(a,b,y),y),d=!1}e.Cartesian3.equalsEpsilon(b,h,m.CesiumMath.EPSILON10)&&(d=!0),(a.tangent||a.bitangent)&&(p=n.geodeticSurfaceNormal(h,p),a.tangent&&(g=e.Cartesian3.normalize(e.Cartesian3.cross(p,y,g),g))),a.normal&&(i[s++]=y.x,i[s++]=y.y,i[s++]=y.z,i[s++]=y.x,i[s++]=y.y,i[s++]=y.z),a.tangent&&(o[u++]=g.x,o[u++]=g.y,o[u++]=g.z,o[u++]=g.x,o[u++]=g.y,o[u++]=g.z),a.bitangent&&(l[c++]=p.x,l[c++]=p.y,l[c++]=p.z,l[c++]=p.x,l[c++]=p.y,l[c++]=p.z)}return L(a,{positions:t,normals:i,tangents:o,bitangents:l})}(tc,F,I);F.st&&(tA.attributes.st=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:tp})),w&&(tA.attributes.extrudeDirection=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:tm})),Z&&(tA.attributes.applyOffset=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:td}));let tx=c.IndexDatatype.createTypedArray(tu,6*to);U=tc.length/3;let tw=0;for(o=0;o<U-1;o+=2){x=((b=o)+2)%U;let t=e.Cartesian3.fromArray(tc,3*b,D),a=e.Cartesian3.fromArray(tc,3*x,M);e.Cartesian3.equalsEpsilon(t,a,m.CesiumMath.EPSILON10)||(A=((_=(b+1)%U)+2)%U,tx[tw++]=b,tx[tw++]=_,tx[tw++]=x,tx[tw++]=x,tx[tw++]=_,tx[tw++]=A)}return tA.indices=tx,(tA=u.GeometryPipeline.combineInstances([new l.GeometryInstance({geometry:z}),new l.GeometryInstance({geometry:tA})]))[0]}(o,w);let a=n.BoundingSphere.fromRectangle3D(h,b,F,V),p=n.BoundingSphere.fromRectangle3D(h,b,I,P);f=n.BoundingSphere.union(a,p)}else{if((y=T(o,w)).attributes.position.values=d.PolygonPipeline.scaleToGeodeticHeight(y.attributes.position.values,F,b,!1),t.defined(o._offsetAttribute)){let t=y.attributes.position.values.length,e=o._offsetAttribute===s.GeometryOffsetAttribute.NONE?0:1,a=new Uint8Array(t/3).fill(e);y.attributes.applyOffset=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}f=n.BoundingSphere.fromRectangle3D(h,b,F)}return x.position||delete y.attributes.position,new i.Geometry({attributes:y.attributes,indices:y.indices,primitiveType:y.primitiveType,boundingSphere:f,offsetAttribute:o._offsetAttribute})},B.createShadowVolume=function(t,e,a){let n=t._granularity,r=t._ellipsoid,i=e(n,r),o=a(n,r);return new B({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:r,stRotation:t._stRotation,granularity:n,extrudedHeight:o,height:i,vertexFormat:g.VertexFormat.POSITION_ONLY,shadowVolume:!0})};let J=new a.Rectangle,j=[new a.Cartesian2,new a.Cartesian2,new a.Cartesian2],Z=new a.Matrix2,K=new e.Cartographic;return Object.defineProperties(B.prototype,{rectangle:{get:function(){return t.defined(this._rotatedRectangle)||(this._rotatedRectangle=z(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return t.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){if(0===t._stRotation)return[0,0,0,1,1,0];let e=a.Rectangle.clone(t._rectangle,J),n=t._granularity,r=t._ellipsoid,i=z(e,n,t._rotation-t._stRotation,r,J),o=j;o[0].x=i.west,o[0].y=i.south,o[1].x=i.west,o[1].y=i.north,o[2].x=i.east,o[2].y=i.south;let l=t.rectangle,s=a.Matrix2.fromRotation(t._stRotation,Z),u=a.Rectangle.center(l,K);for(let t=0;t<3;++t){let e=o[t];e.x-=u.longitude,e.y-=u.latitude,a.Matrix2.multiplyByVector(s,e,e),e.x+=u.longitude,e.y+=u.latitude,e.x=(e.x-l.west)/l.width,e.y=(e.y-l.south)/l.height}let c=o[0],m=o[1],d=o[2],p=Array(6);return a.Cartesian2.pack(c,p),a.Cartesian2.pack(m,p,2),a.Cartesian2.pack(d,p,4),p}(this)),this._textureCoordinateRotationPoints}}}),function(n,r){return t.defined(r)&&(n=B.unpack(n,r)),n._ellipsoid=e.Ellipsoid.clone(n._ellipsoid),n._rectangle=a.Rectangle.clone(n._rectangle),B.createGeometry(n)}});