define(["./defaultValue-f6d5e6da","./Matrix3-81054f0f","./ArcType-26a3f38d","./Transforms-fce95115","./Color-7d827393","./ComponentDatatype-ab629b88","./GeometryAttribute-81ff775c","./GeometryAttributes-1e4ddcd2","./IndexDatatype-d3db4e7d","./Math-2ce22ee9","./PolylinePipeline-8495667b","./Matrix2-413c4048","./RuntimeError-9b4ce3fb","./combine-0c102d93","./WebGLConstants-7f557f93","./EllipsoidGeodesic-2723ab86","./EllipsoidRhumbLine-77eff028","./IntersectionTests-357c3d7f","./Plane-6add0ae1"],function(e,t,o,l,r,i,a,n,s,p,d,f,c,y,u,h,C,T,g){"use strict";function m(l){let i=(l=e.defaultValue(l,e.defaultValue.EMPTY_OBJECT)).positions,a=l.colors,n=e.defaultValue(l.colorsPerVertex,!1);this._positions=i,this._colors=a,this._colorsPerVertex=n,this._arcType=e.defaultValue(l.arcType,o.ArcType.GEODESIC),this._granularity=e.defaultValue(l.granularity,p.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=e.defaultValue(l.ellipsoid,t.Ellipsoid.WGS84),this._workerName="createSimplePolylineGeometry";let s=1+i.length*t.Cartesian3.packedLength;s+=e.defined(a)?1+a.length*r.Color.packedLength:1,this.packedLength=s+t.Ellipsoid.packedLength+3}m.pack=function(o,l,i){let a;i=e.defaultValue(i,0);let n=o._positions,s=n.length;for(l[i++]=s,a=0;a<s;++a,i+=t.Cartesian3.packedLength)t.Cartesian3.pack(n[a],l,i);let p=o._colors;for(s=e.defined(p)?p.length:0,l[i++]=s,a=0;a<s;++a,i+=r.Color.packedLength)r.Color.pack(p[a],l,i);return t.Ellipsoid.pack(o._ellipsoid,l,i),i+=t.Ellipsoid.packedLength,l[i++]=o._colorsPerVertex?1:0,l[i++]=o._arcType,l[i]=o._granularity,l},m.unpack=function(o,l,i){let a;l=e.defaultValue(l,0);let n=o[l++],s=Array(n);for(a=0;a<n;++a,l+=t.Cartesian3.packedLength)s[a]=t.Cartesian3.unpack(o,l);n=o[l++];let p=n>0?Array(n):void 0;for(a=0;a<n;++a,l+=r.Color.packedLength)p[a]=r.Color.unpack(o,l);let d=t.Ellipsoid.unpack(o,l);l+=t.Ellipsoid.packedLength;let f=1===o[l++],c=o[l++],y=o[l];return e.defined(i)?(i._positions=s,i._colors=p,i._ellipsoid=d,i._colorsPerVertex=f,i._arcType=c,i._granularity=y,i):new m({positions:s,colors:p,ellipsoid:d,colorsPerVertex:f,arcType:c,granularity:y})};let b=[,,],P=[,,],_={positions:b,height:P,ellipsoid:void 0,minDistance:void 0,granularity:void 0};return m.createGeometry=function(f){let c;let y=f._positions,u=f._colors,h=f._colorsPerVertex,C=f._arcType,T=f._granularity,g=f._ellipsoid,m=p.CesiumMath.chordLength(T,g.maximumRadius),B=e.defined(u)&&!h,E=y.length,A,k,G,D,L=0;if(C===o.ArcType.GEODESIC||C===o.ArcType.RHUMB){let t,l,i;C===o.ArcType.GEODESIC?(t=p.CesiumMath.chordLength(T,g.maximumRadius),l=d.PolylinePipeline.numberOfPoints,i=d.PolylinePipeline.generateArc):(t=T,l=d.PolylinePipeline.numberOfPointsRhumbLine,i=d.PolylinePipeline.generateRhumbArc);let a=d.PolylinePipeline.extractHeights(y,g),n=_;if(C===o.ArcType.GEODESIC?n.minDistance=m:n.granularity=T,n.ellipsoid=g,B){let o=0;for(c=0;c<E-1;c++)o+=l(y[c],y[c+1],t)+1;A=new Float64Array(3*o),G=new Uint8Array(4*o),n.positions=b,n.height=P;let s=0;for(c=0;c<E-1;++c){b[0]=y[c],b[1]=y[c+1],P[0]=a[c],P[1]=a[c+1];let t=i(n);if(e.defined(u)){let e=t.length/3;D=u[c];for(let t=0;t<e;++t)G[s++]=r.Color.floatToByte(D.red),G[s++]=r.Color.floatToByte(D.green),G[s++]=r.Color.floatToByte(D.blue),G[s++]=r.Color.floatToByte(D.alpha)}A.set(t,L),L+=t.length}}else if(n.positions=y,n.height=a,A=new Float64Array(i(n)),e.defined(u)){for(G=new Uint8Array(A.length/3*4),c=0;c<E-1;++c)L=function(e,t,o,l,i,a,n){let s;let p=d.PolylinePipeline.numberOfPoints(e,t,i),f=o.red,c=o.green,y=o.blue,u=o.alpha,h=l.red,C=l.green,T=l.blue,g=l.alpha;if(r.Color.equals(o,l)){for(s=0;s<p;s++)a[n++]=r.Color.floatToByte(f),a[n++]=r.Color.floatToByte(c),a[n++]=r.Color.floatToByte(y),a[n++]=r.Color.floatToByte(u);return n}let m=(h-f)/p,b=(C-c)/p,P=(T-y)/p,_=(g-u)/p,B=n;for(s=0;s<p;s++)a[B++]=r.Color.floatToByte(f+s*m),a[B++]=r.Color.floatToByte(c+s*b),a[B++]=r.Color.floatToByte(y+s*P),a[B++]=r.Color.floatToByte(u+s*_);return B}(y[c],y[c+1],u[c],u[c+1],m,G,L);let e=u[E-1];G[L++]=r.Color.floatToByte(e.red),G[L++]=r.Color.floatToByte(e.green),G[L++]=r.Color.floatToByte(e.blue),G[L++]=r.Color.floatToByte(e.alpha)}}else{k=B?2*E-2:E,A=new Float64Array(3*k),G=e.defined(u)?new Uint8Array(4*k):void 0;let o=0,l=0;for(c=0;c<E;++c){let i=y[c];if(B&&c>0&&(t.Cartesian3.pack(i,A,o),o+=3,D=u[c-1],G[l++]=r.Color.floatToByte(D.red),G[l++]=r.Color.floatToByte(D.green),G[l++]=r.Color.floatToByte(D.blue),G[l++]=r.Color.floatToByte(D.alpha)),B&&c===E-1)break;t.Cartesian3.pack(i,A,o),o+=3,e.defined(u)&&(D=u[c],G[l++]=r.Color.floatToByte(D.red),G[l++]=r.Color.floatToByte(D.green),G[l++]=r.Color.floatToByte(D.blue),G[l++]=r.Color.floatToByte(D.alpha))}}let V=new n.GeometryAttributes;V.position=new a.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:A}),e.defined(u)&&(V.color=new a.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:G,normalize:!0})),k=A.length/3;let x=2*(k-1),w=s.IndexDatatype.createTypedArray(k,x),S=0;for(c=0;c<k-1;++c)w[S++]=c,w[S++]=c+1;return new a.Geometry({attributes:V,indices:w,primitiveType:a.PrimitiveType.LINES,boundingSphere:l.BoundingSphere.fromPoints(y)})},function(o,l){return e.defined(l)&&(o=m.unpack(o,l)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),m.createGeometry(o)}});