!function(){"use strict";let t;let{Array:e,Object:n,Math:s,Error:i,Uint8Array:r,Uint16Array:a,Uint32Array:l,Int32Array:h,DataView:c,TextEncoder:o,crypto:p,postMessage:d}=globalThis,u=[];for(let t=0;256>t;t++){let e=t;for(let t=0;8>t;t++)1&e?e=e>>>1^3988292384:e>>>=1;u[t]=e}class f{constructor(t){this.crc=t||-1}append(t){let e=0|this.crc;for(let n=0,s=0|t.length;s>n;n++)e=e>>>8^u[255&(e^t[n])];this.crc=e}get(){return~this.crc}}let g={concat(t,e){if(0===t.length||0===e.length)return t.concat(e);let n=t[t.length-1],s=g.getPartial(n);return 32===s?t.concat(e):g._shiftRight(e,s,0|n,t.slice(0,t.length-1))},bitLength(t){let e=t.length;if(0===e)return 0;let n=t[e-1];return 32*(e-1)+g.getPartial(n)},clamp(t,e){if(32*t.length<e)return t;let n=(t=t.slice(0,s.ceil(e/32))).length;return e&=31,n>0&&e&&(t[n-1]=g.partial(e,t[n-1]&2147483648>>e-1,1)),t},partial:(t,e,n)=>32===t?e:(n?0|e:e<<32-t)+1099511627776*t,getPartial:t=>s.round(t/1099511627776)||32,_shiftRight(t,e,n,s){for(void 0===s&&(s=[]);e>=32;e-=32)s.push(n),n=0;if(0===e)return s.concat(t);for(let i=0;i<t.length;i++)s.push(n|t[i]>>>e),n=t[i]<<32-e;let i=t.length?t[t.length-1]:0,r=g.getPartial(i);return s.push(g.partial(e+r&31,e+r>32?n:s.pop(),1)),s}},w={bytes:{fromBits(t){let e;let n=g.bitLength(t)/8,s=new r(n);for(let i=0;n>i;i++)3&i||(e=t[i/4]),s[i]=e>>>24,e<<=8;return s},toBits(t){let e=[],n,s=0;for(n=0;n<t.length;n++)s=s<<8|t[n],(3&n)==3&&(e.push(s),s=0);return 3&n&&e.push(g.partial(8*(3&n),s)),e}}},y={sha1:function(t){t?(this._h=t._h.slice(0),this._buffer=t._buffer.slice(0),this._length=t._length):this.reset()}};y.sha1.prototype={blockSize:512,reset:function(){let t=this;return t._h=this._init.slice(0),t._buffer=[],t._length=0,t},update:function(t){let e=this;"string"==typeof t&&(t=w.utf8String.toBits(t));let n=e._buffer=g.concat(e._buffer,t),s=e._length,r=e._length=s+g.bitLength(t);if(r>9007199254740991)throw new i("Cannot hash more than 2^53 - 1 bits");let a=new l(n),h=0;for(let t=e.blockSize+s-(e.blockSize+s&e.blockSize-1);r>=t;t+=e.blockSize)e._block(a.subarray(16*h,16*(h+1))),h+=1;return n.splice(0,16*h),e},finalize:function(){let t=this._buffer,e=this._h;t=g.concat(t,[g.partial(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(s.floor(this._length/4294967296)),t.push(0|this._length);t.length;)this._block(t.splice(0,16));return this.reset(),e},_init:[1732584193,4023233417,2562383102,271733878,3285377520],_key:[1518500249,1859775393,2400959708,3395469782],_f:(t,e,n,s)=>t>19?t>39?t>59?t>79?void 0:e^n^s:e&n|e&s|n&s:e^n^s:e&n|~e&s,_S:(t,e)=>e<<t|e>>>32-t,_block:function(t){let n=this._h,i=e(80);for(let e=0;16>e;e++)i[e]=t[e];let r=n[0],a=n[1],l=n[2],h=n[3],c=n[4];for(let t=0;79>=t;t++){16>t||(i[t]=this._S(1,i[t-3]^i[t-8]^i[t-14]^i[t-16]));let e=this._S(5,r)+this._f(t,a,l,h)+c+i[t]+this._key[s.floor(t/20)]|0;c=h,h=l,l=this._S(30,a),a=r,r=e}n[0]=n[0]+r|0,n[1]=n[1]+a|0,n[2]=n[2]+l|0,n[3]=n[3]+h|0,n[4]=n[4]+c|0}};let _={getRandomValues(t){let e=new l(t.buffer),n=t=>{let e=987654321;return()=>((((e=36969*(65535&e)+(e>>16)&4294967295)<<16)+(t=18e3*(65535&t)+(t>>16)&4294967295)&4294967295)/4294967296+.5)*(s.random()>.5?1:-1)};for(let i,r=0;r<t.length;r+=4){let t=n(4294967296*(i||s.random()));i=987654071*t(),e[r/4]=4294967296*t()|0}return t}},m={importKey:t=>new m.hmacSha1(w.bytes.toBits(t)),pbkdf2(t,e,n,s){let r,a,l,h,o;if(n=n||1e4,0>s||0>n)throw new i("invalid params to pbkdf2");let p=1+(s>>5)<<2,d=new ArrayBuffer(p),u=new c(d),f=0;for(e=w.bytes.toBits(e),o=1;(p||1)>f;o++){for(r=a=t.encrypt(g.concat(e,[o])),l=1;n>l;l++)for(a=t.encrypt(a),h=0;h<a.length;h++)r[h]^=a[h];for(l=0;(p||1)>f&&l<r.length;l++)u.setInt32(f,r[l]),f+=4}return d.slice(0,s/8)},hmacSha1:class{constructor(t){let e=this,n=e._hash=y.sha1,s=[[],[]],i=n.prototype.blockSize/32;e._baseHash=[new n,new n],t.length>i&&(t=n.hash(t));for(let e=0;i>e;e++)s[0][e]=909522486^t[e],s[1][e]=1549556828^t[e];e._baseHash[0].update(s[0]),e._baseHash[1].update(s[1]),e._resultHash=new n(e._baseHash[0])}reset(){let t=this;t._resultHash=new t._hash(t._baseHash[0]),t._updated=!1}update(t){this._updated=!0,this._resultHash.update(t)}digest(){let t=this._resultHash.finalize(),e=new this._hash(this._baseHash[1]).update(t).finalize();return this.reset(),e}encrypt(t){if(this._updated)throw new i("encrypt on already updated hmac called!");return this.update(t),this.digest(t)}}},b="Invalid pasword",k={name:"PBKDF2"},v=n.assign({hash:{name:"HMAC"}},k),z=n.assign({iterations:1e3,hash:{name:"SHA-1"}},k),C=["deriveBits"],S=[8,12,16],B=[16,24,32],I=[0,0,0,0],D=void 0!==p,V=D&&void 0!==p.subtle,H=w.bytes,K=class{constructor(t){let e=this;e._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],e._tables[0][0][0]||e._precompute();let n=e._tables[0][4],s=e._tables[1],r=t.length,a,l,h,c=1;if(4!==r&&6!==r&&8!==r)throw new i("invalid aes key size");for(e._key=[l=t.slice(0),h=[]],a=r;4*r+28>a;a++){let t=l[a-1];(a%r==0||8===r&&a%r==4)&&(t=n[t>>>24]<<24^n[t>>16&255]<<16^n[t>>8&255]<<8^n[255&t],a%r==0&&(t=t<<8^t>>>24^c<<24,c=c<<1^283*(c>>7))),l[a]=l[a-r]^t}for(let t=0;a;t++,a--){let e=l[3&t?a:a-4];h[t]=4>=a||4>t?e:s[0][n[e>>>24]]^s[1][n[e>>16&255]]^s[2][n[e>>8&255]]^s[3][n[255&e]]}}encrypt(t){return this._crypt(t,0)}decrypt(t){return this._crypt(t,1)}_precompute(){let t,e,n;let s=this._tables[0],i=this._tables[1],r=s[4],a=i[4],l=[],h=[];for(let t=0;256>t;t++)h[(l[t]=t<<1^283*(t>>7))^t]=t;for(let c=t=0;!r[c];c^=e||1,t=h[t]||1){let h=t^t<<1^t<<2^t<<3^t<<4;h=h>>8^255&h^99,r[c]=h,a[h]=c;let o=16843009*l[n=l[e=l[c]]]^65537*n^257*e^16843008*c,p=257*l[h]^16843008*h;for(let t=0;4>t;t++)s[t][c]=p=p<<24^p>>>8,i[t][h]=o=o<<24^o>>>8}for(let t=0;5>t;t++)s[t]=s[t].slice(0),i[t]=i[t].slice(0)}_crypt(t,e){if(4!==t.length)throw new i("invalid aes block size");let n=this._key[e],s=n.length/4-2,r=[0,0,0,0],a=this._tables[e],l=a[0],h=a[1],c=a[2],o=a[3],p=a[4],d,u,f,g=t[0]^n[0],w=t[e?3:1]^n[1],y=t[2]^n[2],_=t[e?1:3]^n[3],m=4;for(let t=0;s>t;t++)d=l[g>>>24]^h[w>>16&255]^c[y>>8&255]^o[255&_]^n[m],u=l[w>>>24]^h[y>>16&255]^c[_>>8&255]^o[255&g]^n[m+1],f=l[y>>>24]^h[_>>16&255]^c[g>>8&255]^o[255&w]^n[m+2],_=l[_>>>24]^h[g>>16&255]^c[w>>8&255]^o[255&y]^n[m+3],m+=4,g=d,w=u,y=f;for(let t=0;4>t;t++)r[e?3&-t:t]=p[g>>>24]<<24^p[w>>16&255]<<16^p[y>>8&255]<<8^p[255&_]^n[m++],d=g,g=w,w=y,y=_,_=d;return r}},A=class{constructor(t,e){this._prf=t,this._initIv=e,this._iv=e}reset(){this._iv=this._initIv}update(t){return this.calculate(this._prf,t,this._iv)}incWord(t){if((t>>24&255)==255){let e=t>>16&255,n=t>>8&255,s=255&t;255===e?(e=0,255===n?(n=0,255===s?s=0:++s):++n):++e,t=0+(e<<16)+(n<<8)+s}else t+=16777216;return t}incCounter(t){0===(t[0]=this.incWord(t[0]))&&(t[1]=this.incWord(t[1]))}calculate(t,e,n){let s;if(!(s=e.length))return[];let i=g.bitLength(e);for(let i=0;s>i;i+=4){this.incCounter(n);let s=t.encrypt(n);e[i]^=s[0],e[i+1]^=s[1],e[i+2]^=s[2],e[i+3]^=s[3]}return g.clamp(e,i)}},R=m.hmacSha1;class W{constructor(t,e,s){n.assign(this,{password:t,signed:e,strength:s-1,pendingInput:new r(0)})}async append(t){let n=this;if(n.password){let s=P(t,0,S[n.strength]+2);await (async(t,e,n)=>{await G(t,n,P(e,0,S[t.strength]));let s=P(e,S[t.strength]),r=t.keys.passwordVerification;if(r[0]!=s[0]||r[1]!=s[1])throw new i(b)})(n,s,n.password),n.password=null,n.aesCtrGladman=new A(new K(n.keys.key),e.from(I)),n.hmac=new R(n.keys.authentication),t=P(t,S[n.strength]+2)}return U(n,t,new r(t.length-10-(t.length-10)%16),0,10,!0)}flush(){let t=this.pendingInput,e=P(t,0,t.length-10),n=P(t,t.length-10),s=new r(0);if(e.length){let t=H.toBits(e);this.hmac.update(t);let n=this.aesCtrGladman.update(t);s=H.fromBits(n)}let i=!0;if(this.signed){let t=P(H.fromBits(this.hmac.digest()),0,10);for(let e=0;10>e;e++)t[e]!=n[e]&&(i=!1)}return{valid:i,data:s}}}class T{constructor(t,e){n.assign(this,{password:t,strength:e-1,pendingInput:new r(0)})}async append(t){let n=this,s=new r(0);n.password&&(s=await (async(t,e)=>{var n;let s=(n=new r(S[t.strength]),D&&"function"==typeof p.getRandomValues?p.getRandomValues(n):_.getRandomValues(n));return await G(t,e,s),L(s,t.keys.passwordVerification)})(n,n.password),n.password=null,n.aesCtrGladman=new A(new K(n.keys.key),e.from(I)),n.hmac=new R(n.keys.authentication));let i=new r(s.length+t.length-t.length%16);return i.set(s,0),U(n,t,i,s.length,0)}flush(){let t=new r(0);if(this.pendingInput.length){let e=this.aesCtrGladman.update(H.toBits(this.pendingInput));this.hmac.update(e),t=H.fromBits(e)}let e=P(H.fromBits(this.hmac.digest()),0,10);return{data:L(t,e),signature:e}}}function U(t,e,n,s,i,a){let l;let h=e.length-i;for(t.pendingInput.length&&(e=L(t.pendingInput,e),n=((t,e)=>{if(e&&e>t.length){let n=t;(t=new r(e)).set(n,0)}return t})(n,h-h%16)),l=0;h-16>=l;l+=16){let i=H.toBits(P(e,l,l+16));a&&t.hmac.update(i);let r=t.aesCtrGladman.update(i);a||t.hmac.update(r),n.set(H.fromBits(r),l+s)}return t.pendingInput=P(e,l),n}async function G(t,e,s){let i=(t=>{if(void 0===o){let e=new r((t=unescape(encodeURIComponent(t))).length);for(let n=0;n<e.length;n++)e[n]=t.charCodeAt(n);return e}return new o().encode(t)})(e),a=await (D&&V&&"function"==typeof p.subtle.importKey?p.subtle.importKey("raw",i,v,!1,C):m.importKey(i)),l=await (async(t,e,n)=>D&&V&&"function"==typeof p.subtle.deriveBits?await p.subtle.deriveBits(t,e,n):m.pbkdf2(e,t.salt,z.iterations,n))(n.assign({salt:s},z),a,8*(2*B[t.strength]+2)),h=new r(l);t.keys={key:H.toBits(P(h,0,B[t.strength])),authentication:H.toBits(P(h,B[t.strength],2*B[t.strength])),passwordVerification:P(h,2*B[t.strength])}}function L(t,e){let n=t;return t.length+e.length&&((n=new r(t.length+e.length)).set(t,0),n.set(e,t.length)),n}function P(t,e,n){return t.subarray(e,n)}class E{constructor(t,e){n.assign(this,{password:t,passwordVerification:e}),F(this,t)}append(t){let e=this;if(e.password){let n=j(e,t.subarray(0,12));if(e.password=null,n[11]!=e.passwordVerification)throw new i(b);t=t.subarray(12)}return j(e,t)}flush(){return{valid:!0,data:new r(0)}}}class M{constructor(t,e){n.assign(this,{password:t,passwordVerification:e}),F(this,t)}append(t){let e,n;let s=this;if(s.password){s.password=null;let i=p.getRandomValues(new r(12));i[11]=s.passwordVerification,(e=new r(t.length+i.length)).set(x(s,i),0),n=12}else e=new r(t.length),n=0;return e.set(x(s,t),n),e}flush(){return{data:new r(0)}}}function j(t,e){let n=new r(e.length);for(let s=0;s<e.length;s++)n[s]=q(t)^e[s],O(t,n[s]);return n}function x(t,e){let n=new r(e.length);for(let s=0;s<e.length;s++)n[s]=q(t)^e[s],O(t,e[s]);return n}function F(t,e){t.keys=[305419896,591751049,878082192],t.crcKey0=new f(t.keys[0]),t.crcKey2=new f(t.keys[2]);for(let n=0;n<e.length;n++)O(t,e.charCodeAt(n))}function O(t,e){var n;t.crcKey0.append([e]),t.keys[0]=~t.crcKey0.get(),t.keys[1]=J(t.keys[1]+(255&t.keys[0])),t.keys[1]=J(s.imul(t.keys[1],134775813)+1),t.crcKey2.append([t.keys[1]>>>24]),t.keys[2]=~t.crcKey2.get()}function q(t){var e;let n=2|t.keys[2];return 255&s.imul(n,1^n)>>>8}function J(t){return 4294967295&t}let N="deflate",Q="inflate",X="Invalid signature";class Y{constructor(t,{signature:e,password:s,signed:i,compressed:r,zipCrypto:a,passwordVerification:l,encryptionStrength:h},{chunkSize:c}){let o=!!s;n.assign(this,{signature:e,encrypted:o,signed:i,compressed:r,inflate:r&&new t({chunkSize:c}),crc32:i&&new f,zipCrypto:a,decrypt:o&&a?new E(s,l):new W(s,i,h)})}async append(t){return this.encrypted&&t.length&&(t=await this.decrypt.append(t)),this.compressed&&t.length&&(t=await this.inflate.append(t)),(!this.encrypted||this.zipCrypto)&&this.signed&&t.length&&this.crc32.append(t),t}async flush(){let t,e=new r(0);if(this.encrypted){let t=this.decrypt.flush();if(!t.valid)throw new i(X);e=t.data}if((!this.encrypted||this.zipCrypto)&&this.signed){let e=new c(new r(4).buffer);if(t=this.crc32.get(),e.setUint32(0,t),this.signature!=e.getUint32(0,!1))throw new i(X)}return this.compressed&&(e=await this.inflate.append(e)||new r(0),await this.inflate.flush()),{data:e,signature:t}}}class Z{constructor(t,{encrypted:e,signed:s,compressed:i,level:r,zipCrypto:a,password:l,passwordVerification:h,encryptionStrength:c},{chunkSize:o}){n.assign(this,{encrypted:e,signed:s,compressed:i,deflate:i&&new t({level:r||5,chunkSize:o}),crc32:s&&new f,zipCrypto:a,encrypt:e&&a?new M(l,h):new T(l,c)})}async append(t){let e=t;return this.compressed&&t.length&&(e=await this.deflate.append(t)),this.encrypted&&e.length&&(e=await this.encrypt.append(e)),(!this.encrypted||this.zipCrypto)&&this.signed&&t.length&&this.crc32.append(t),e}async flush(){let t,e=new r(0);if(this.compressed&&(e=await this.deflate.flush()||new r(0)),this.encrypted){e=await this.encrypt.append(e);let n=this.encrypt.flush();t=n.signature;let s=new r(e.length+n.data.length);s.set(e,0),s.set(n.data,e.length),e=s}return(!this.encrypted||this.zipCrypto)&&this.signed&&(t=this.crc32.get()),{data:e,signature:t}}}let $={init(e){var n,s;let i;e.scripts&&e.scripts.length&&importScripts.apply(void 0,e.scripts);let r=e.options;self.initCodec&&self.initCodec(),r.codecType.startsWith(N)?i=self.Deflate:r.codecType.startsWith(Q)&&(i=self.Inflate),n=i,s=e.config,t=r.codecType.startsWith(N)?new Z(n,r,s):r.codecType.startsWith(Q)?new Y(n,r,s):void 0},append:async e=>({data:await t.append(e.data)}),flush:()=>t.flush()};function tt(t,e,s){return class{constructor(i){let a=this;a.codec=new t(n.assign({},e,i)),s(a.codec,t=>{if(a.pendingData){let e=a.pendingData;a.pendingData=new r(e.length+t.length),a.pendingData.set(e,0),a.pendingData.set(t,e.length)}else a.pendingData=new r(t)})}append(t){return this.codec.push(t),i(this)}flush(){return this.codec.push(new r(0),!0),i(this)}};function i(t){if(t.pendingData){let e=t.pendingData;return t.pendingData=null,e}return new r(0)}}addEventListener("message",async t=>{let e=t.data,n=e.type,s=$[n];if(s)try{e.data&&(e.data=new r(e.data));let t=await s(e)||{};if(t.type=n,t.data)try{t.data=t.data.buffer,d(t,[t.data])}catch{d(t)}else d(t)}catch(t){d({type:n,error:{message:t.message,stack:t.stack}})}}),self.initCodec=()=>{let{Deflate:t,Inflate:e}=((t,e={},n)=>({Deflate:tt(t.Deflate,e.deflate,n),Inflate:tt(t.Inflate,e.inflate,n)}))(pako,{deflate:{raw:!0},inflate:{raw:!0}},(t,e)=>t.onData=e);self.Deflate=t,self.Inflate=e}}();